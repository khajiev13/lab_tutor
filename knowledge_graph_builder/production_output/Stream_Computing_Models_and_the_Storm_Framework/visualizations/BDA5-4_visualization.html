<style>
.lx-highlight { position: relative; border-radius:3px; padding:1px 2px;}
.lx-highlight .lx-tooltip {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s ease-in-out;
  background: #333;
  color: #fff;
  text-align: left;
  border-radius: 4px;
  padding: 6px 8px;
  position: absolute;
  z-index: 1000;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  max-width: 240px;
  white-space: normal;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}
.lx-highlight:hover .lx-tooltip { visibility: visible; opacity:1; }
.lx-animated-wrapper { max-width: 100%; font-family: Arial, sans-serif; }
.lx-controls {
  background: #fafafa; border: 1px solid #90caf9; border-radius: 8px;
  padding: 12px; margin-bottom: 16px;
}
.lx-button-row {
  display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;
}
.lx-control-btn {
  background: #4285f4; color: white; border: none; border-radius: 4px;
  padding: 8px 16px; cursor: pointer; font-size: 13px; font-weight: 500;
  transition: background-color 0.2s;
}
.lx-control-btn:hover { background: #3367d6; }
.lx-progress-container {
  margin-bottom: 8px;
}
.lx-progress-slider {
  width: 100%; margin: 0; appearance: none; height: 6px;
  background: #ddd; border-radius: 3px; outline: none;
}
.lx-progress-slider::-webkit-slider-thumb {
  appearance: none; width: 18px; height: 18px; background: #4285f4;
  border-radius: 50%; cursor: pointer;
}
.lx-progress-slider::-moz-range-thumb {
  width: 18px; height: 18px; background: #4285f4; border-radius: 50%;
  cursor: pointer; border: none;
}
.lx-status-text {
  text-align: center; font-size: 12px; color: #666; margin-top: 4px;
}
.lx-text-window {
  font-family: monospace; white-space: pre-wrap; border: 1px solid #90caf9;
  padding: 12px; max-height: 260px; overflow-y: auto; margin-bottom: 12px;
  line-height: 1.6;
}
.lx-attributes-panel {
  background: #fafafa; border: 1px solid #90caf9; border-radius: 6px;
  padding: 8px 10px; margin-top: 8px; font-size: 13px;
}
.lx-current-highlight {
  border-bottom: 4px solid #ff4444;
  font-weight: bold;
  animation: lx-pulse 1s ease-in-out;
}
@keyframes lx-pulse {
  0% { text-decoration-color: #ff4444; }
  50% { text-decoration-color: #ff0000; }
  100% { text-decoration-color: #ff4444; }
}
.lx-legend {
  font-size: 12px; margin-bottom: 8px;
  padding-bottom: 8px; border-bottom: 1px solid #e0e0e0;
}
.lx-label {
  display: inline-block;
  padding: 2px 4px;
  border-radius: 3px;
  margin-right: 4px;
  color: #000;
}
.lx-attr-key {
  font-weight: 600;
  color: #1565c0;
  letter-spacing: 0.3px;
}
.lx-attr-value {
  font-weight: 400;
  opacity: 0.85;
  letter-spacing: 0.2px;
}

/* Add optimizations with larger fonts and better readability for GIFs */
.lx-gif-optimized .lx-text-window { font-size: 16px; line-height: 1.8; }
.lx-gif-optimized .lx-attributes-panel { font-size: 15px; }
.lx-gif-optimized .lx-current-highlight { text-decoration-thickness: 4px; }
</style>
    <div class="lx-animated-wrapper lx-gif-optimized">
      <div class="lx-attributes-panel">
        <div class="lx-legend">Highlights Legend: <span class="lx-label" style="background-color:#D2E3FC;">CONCEPT</span> <span class="lx-label" style="background-color:#C8E6C9;">SUMMARY</span> <span class="lx-label" style="background-color:#FEF0C3;">TOPIC</span></div>
        <div id="attributesContainer"></div>
      </div>
      <div class="lx-text-window" id="textWindow">
        Hello everyone, I am Haiying Che, from Institute of Data Science and knowledge Engineering
School of Computer Science, in Beijing Institute of Technology, 
in <span class="lx-highlight lx-current-highlight" data-idx="0" style="background-color:#C8E6C9;">this session</span>, we discuss <span class="lx-highlight" data-idx="1" style="background-color:#D2E3FC;">Stream computing</span> model.
The data processing system provides big data computing and processing capabilities and an application development platform.
From the perspective of computing architecture, the data processing system is divided into data algorithm layer, computing model layer, computing platform layer, computing engine layer, etc.
Computing models are the way that different kinds of big data is processed in different scenarios, 
which include batch processing, stream computing, Large-scale concurrent processing (MPP) model for structured data, In-memory Computing model, and Data Flow Graph models.
Now let’s look at the stream computing model represented by Storm
Stream computing is a computing model that processes real-time dynamic data. 
The traditional enterprise database stores historical data, that is, static data, that is, all data must be entered into the database before calculation and processing. 
Technicians can query and update the database, and use data mining and OLAP analysis tools to extract static data from the database. Find valuable information to support business decision analysis.
However, in Internet applications (user web click tracking, online real-time recommendation systems, etc.), intelligent transportation systems, wireless sensor network monitoring and other fields, its data generation methods and data characteristics have the following characteristics and calculation requirements
）Data is no longer arriving in batches but continuously arriving dynamically
）Computational analysis requires real-time, fast response, and low latency
）The amount of data is large, but the storage of the data is not valued, but the immediate processing and analysis of the data are emphasized
）Pay attention to the calculation and analysis results of the data as a whole, but not to pay attention to the individual data
）The order and timing of the arrival of data elements cannot be predicted or controlled, and the calculation program must be able to respond
<span class="lx-highlight" data-idx="2" style="background-color:#D2E3FC;">MapReduce</span> performs offline batch calculations for static data that has entered the database, and the calculation results are also stored in the static database; 
while <span class="lx-highlight" data-idx="3" style="background-color:#FEF0C3;">stream computing is real-time analysis and calculation for dynamic continuous data streams. 
After the calculation results are obtained, the data is either imported into the static database, either discard, that is, one-time use.
To support this data flow calculation mode, the flow calculation framework generally includes three steps: real-time data collection, real-time data calculation, real-time data query service
<span class="lx-highlight" data-idx="4" style="background-color:#D2E3FC;">Directed Acyclic Graph (DAG, Directed Acyclic Graph)</span> is commonly used in distributed systems to characterize the calculation process or calculation model.
The figure shows the combination of chained tasks in a distributed system. 
The nodes in different colors in the figure represent computing tasks (or computing objects) at different stages.
The one-way arrow indicates the order of the calculation steps and the dependencies.
<span class="lx-highlight" data-idx="5" style="background-color:#D2E3FC;">Storm</span></span> is a <span class="lx-highlight" data-idx="6" style="background-color:#D2E3FC;">Native Stream Processing System</span>, that is, the processing of stream data is based on each piece of data, and its parallel calculation is implemented based on a directed <span class="lx-highlight" data-idx="7" style="background-color:#D2E3FC;">topology</span> graph.
Topology composed of <span class="lx-highlight" data-idx="8" style="background-color:#D2E3FC;">Spout</span> (data source) and <span class="lx-highlight" data-idx="9" style="background-color:#D2E3FC;">Bolt</span> (processing unit).
Topology Defines the logical model (or abstract model) of parallel computing, that is, designs the calculation steps and processes from the perspective of function and architecture.
The out put of a spout is a series of tuples stream, and the input and output of Bolt is also is a series of tuples stream.
Storm&#x27;s computing system also adopts a master-slave (Master/Slave) architecture. There are mainly two types of nodes: master node and slave node.   
A <span class="lx-highlight" data-idx="10" style="background-color:#D2E3FC;">Nimbus</span> daemon runs on the master node, like Hadoop&#x27;s JobTracker, responsible for task distribution and fault monitoring of the cluster.
Nimbus manages many worker nodes through a group of Zookeeper   
Each worker node runs a <span class="lx-highlight" data-idx="11" style="background-color:#D2E3FC;">Supervisor</span> daemon, monitors the status of the local node, and starts and shuts down the worker process of the node when necessary according to Nimbus instructions.
There are two ways of stream computing, Native Stream Processing System represented by storm and <span class="lx-highlight" data-idx="12" style="background-color:#D2E3FC;">Micro-batch Stream Processing System</span> represented by spark
Micro-batch processing is the practice of collecting data in small groups (“batches”) for the purposes of taking action on (processing) that data.
Compared with Native Stream Processing System, Micro-batch processing is not really Realtime processing , but nearly Realtime processing , it can save the computing cost because it wait until the micro batch composed.
Contrast this to traditional “batch processing,” which often implies taking action on a large group of data. 
Micro-batch processing is a variant of traditional batch processing in that the data processing occurs more frequently so that smaller groups of new data are processed. In both micro-batch processing and traditional batch processing, data is collected based on a predetermined threshold or frequency before any processing occurs.
During the real application, sometimes the Batch computing and Stream computing combined to finish the history records analysis and Realtime analysis like showed in the diagram.
Kafka broker take the data form the data producer, and deliver them into Stream computing storm cluster and the Batch computing Hadoop cluster, the processing output of storm can be stored in NoSQL Cassandra DB The output of Batch processing can be stored in Hbase.
After the data has been processed, the data analytics like virtualization, decision making, Prediction, OLAP and recommendation can be done based on the result of Batch processing and Stream processing. 
In this session we learned stream computing represented by Storm.
Thank you for your attention, if you have any question, feel free to contact me.
      </div>
      <div class="lx-controls">
        <div class="lx-button-row">
          <button class="lx-control-btn" onclick="playPause()">▶️ Play</button>
          <button class="lx-control-btn" onclick="prevExtraction()">⏮ Previous</button>
          <button class="lx-control-btn" onclick="nextExtraction()">⏭ Next</button>
        </div>
        <div class="lx-progress-container">
          <input type="range" id="progressSlider" class="lx-progress-slider"
                 min="0" max="12" value="0"
                 onchange="jumpToExtraction(this.value)">
        </div>
        <div class="lx-status-text">
          Entity <span id="entityInfo">1/13</span> |
          Pos <span id="posInfo">[2351-3207]</span>
        </div>
      </div>
    </div>

    <script>
      (function() {
        const extractions = [{"index": 0, "class": "SUMMARY", "text": "This session introduces stream computing as a model for processing real-time, dynamic data, contrasting it with traditional batch processing like MapReduce which handles static, historical data. Stream computing is characterized by continuous data arrival, the need for low-latency responses, and a focus on immediate analysis rather than storage. The process typically involves three steps: real-time data collection, computation, and query services. The lecture details the Storm framework, a native stream processing system that uses a Directed Acyclic Graph (DAG) topology composed of Spouts (data sources) and Bolts (processing units) to define its parallel computation logic. Storm's master-slave architecture consists of a Nimbus master node for task distribution and Supervisor daemons on worker nodes. The session also compares native stream processing with micro-batch processing, a near-real-time approach that processes data in small batches. Finally, it describes hybrid architectures where stream computing (Storm) and batch computing (Hadoop) are combined, often using Kafka for data ingestion and NoSQL databases like Cassandra or HBase for storing processed results, which then feed into analytics applications.", "color": "#C8E6C9", "startPos": 159, "endPos": 171, "beforeText": "ryone, I am Haiying Che, from Institute of Data Science and knowledge Engineering\nSchool of Computer Science, in Beijing Institute of Technology, \nin ", "extractionText": "this session", "afterText": ", we discuss Stream computing model.\nThe data processing system provides big data computing and processing capabilities and an application development", "attributesHtml": "<div><strong>class:</strong> SUMMARY</div><div><strong>attributes:</strong> {}</div>"}, {"index": 1, "class": "CONCEPT", "text": "Stream Computing", "color": "#D2E3FC", "startPos": 184, "endPos": 200, "beforeText": "from Institute of Data Science and knowledge Engineering\nSchool of Computer Science, in Beijing Institute of Technology, \nin this session, we discuss ", "extractionText": "Stream computing", "afterText": " model.\nThe data processing system provides big data computing and processing capabilities and an application development platform.\nFrom the perspecti", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A computing model that processes real-time dynamic data, as opposed to traditional databases that store and process static, historical data.</span>}</div>"}, {"index": 2, "class": "CONCEPT", "text": "MapReduce", "color": "#D2E3FC", "startPos": 2183, "endPos": 2192, "beforeText": "ual data\n\uff09The order and timing of the arrival of data elements cannot be predicted or controlled, and the calculation program must be able to respond\n", "extractionText": "MapReduce", "afterText": " performs offline batch calculations for static data that has entered the database, and the calculation results are also stored in the static database", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A model that performs offline batch calculations for static data that has already been stored in a database.</span>}</div>"}, {"index": 3, "class": "TOPIC", "text": "Stream Computing Models and the Storm Framework", "color": "#FEF0C3", "startPos": 2351, "endPos": 3207, "beforeText": " offline batch calculations for static data that has entered the database, and the calculation results are also stored in the static database; \nwhile ", "extractionText": "stream computing is real-time analysis and calculation for dynamic continuous data streams. \nAfter the calculation results are obtained, the data is either imported into the static database, either discard, that is, one-time use.\nTo support this data flow calculation mode, the flow calculation framework generally includes three steps: real-time data collection, real-time data calculation, real-time data query service\nDirected Acyclic Graph (DAG, Directed Acyclic Graph) is commonly used in distributed systems to characterize the calculation process or calculation model.\nThe figure shows the combination of chained tasks in a distributed system. \nThe nodes in different colors in the figure represent computing tasks (or computing objects) at different stages.\nThe one-way arrow indicates the order of the calculation steps and the dependencies.\nStorm", "afterText": " is a Native Stream Processing System, that is, the processing of stream data is based on each piece of data, and its parallel calculation is implemen", "attributesHtml": "<div><strong>class:</strong> TOPIC</div><div><strong>attributes:</strong> {}</div>"}, {"index": 4, "class": "CONCEPT", "text": "Directed Acyclic Graph (DAG)", "color": "#D2E3FC", "startPos": 2772, "endPos": 2824, "beforeText": "e, the flow calculation framework generally includes three steps: real-time data collection, real-time data calculation, real-time data query service\n", "extractionText": "Directed Acyclic Graph (DAG, Directed Acyclic Graph)", "afterText": " is commonly used in distributed systems to characterize the calculation process or calculation model.\nThe figure shows the combination of chained tas", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A model commonly used in distributed systems to characterize the calculation process, where nodes represent computing tasks and one-way arrows indicate the order and dependencies of calculation steps.</span>}</div>"}, {"index": 5, "class": "CONCEPT", "text": "Storm", "color": "#D2E3FC", "startPos": 3202, "endPos": 3207, "beforeText": "sent computing tasks (or computing objects) at different stages.\nThe one-way arrow indicates the order of the calculation steps and the dependencies.\n", "extractionText": "Storm", "afterText": " is a Native Stream Processing System, that is, the processing of stream data is based on each piece of data, and its parallel calculation is implemen", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A Native Stream Processing System where the processing of stream data is based on each individual piece of data, and its parallel calculation is implemented based on a directed topology graph.</span>}</div>"}, {"index": 6, "class": "CONCEPT", "text": "Native Stream Processing System", "color": "#D2E3FC", "startPos": 3213, "endPos": 3244, "beforeText": "ing tasks (or computing objects) at different stages.\nThe one-way arrow indicates the order of the calculation steps and the dependencies.\nStorm is a ", "extractionText": "Native Stream Processing System", "afterText": ", that is, the processing of stream data is based on each piece of data, and its parallel calculation is implemented based on a directed topology grap", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A stream computing approach, represented by Storm, where the processing of stream data is based on each individual piece of data.</span>}</div>"}, {"index": 7, "class": "CONCEPT", "text": "Topology", "color": "#D2E3FC", "startPos": 3381, "endPos": 3389, "beforeText": "essing System, that is, the processing of stream data is based on each piece of data, and its parallel calculation is implemented based on a directed ", "extractionText": "topology", "afterText": " graph.\nTopology composed of Spout (data source) and Bolt (processing unit).\nTopology Defines the logical model (or abstract model) of parallel comput", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">In Storm, it defines the logical model or abstract model of parallel computing, composed of Spouts (data sources) and Bolts (processing units).</span>}</div>"}, {"index": 8, "class": "CONCEPT", "text": "Spout", "color": "#D2E3FC", "startPos": 3418, "endPos": 3423, "beforeText": "g of stream data is based on each piece of data, and its parallel calculation is implemented based on a directed topology graph.\nTopology composed of ", "extractionText": "Spout", "afterText": " (data source) and Bolt (processing unit).\nTopology Defines the logical model (or abstract model) of parallel computing, that is, designs the calculat", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">The data source in a Storm topology, which outputs a series of tuples stream.</span>}</div>"}, {"index": 9, "class": "CONCEPT", "text": "Bolt", "color": "#D2E3FC", "startPos": 3442, "endPos": 3446, "beforeText": "d on each piece of data, and its parallel calculation is implemented based on a directed topology graph.\nTopology composed of Spout (data source) and ", "extractionText": "Bolt", "afterText": " (processing unit).\nTopology Defines the logical model (or abstract model) of parallel computing, that is, designs the calculation steps and processes", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A processing unit in a Storm topology whose input and output are a series of tuples stream.</span>}</div>"}, {"index": 10, "class": "CONCEPT", "text": "Nimbus", "color": "#D2E3FC", "startPos": 3923, "endPos": 3929, "beforeText": "torm&#x27;s computing system also adopts a master-slave (Master/Slave) architecture. There are mainly two types of nodes: master node and slave node.   \nA ", "extractionText": "Nimbus", "afterText": " daemon runs on the master node, like Hadoop&#x27;s JobTracker, responsible for task distribution and fault monitoring of the cluster.\nNimbus manages many ", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A daemon that runs on the master node in a Storm cluster, responsible for task distribution and fault monitoring, similar to Hadoop&#x27;s JobTracker.</span>}</div>"}, {"index": 11, "class": "CONCEPT", "text": "Supervisor", "color": "#D2E3FC", "startPos": 4148, "endPos": 4158, "beforeText": "e for task distribution and fault monitoring of the cluster.\nNimbus manages many worker nodes through a group of Zookeeper   \nEach worker node runs a ", "extractionText": "Supervisor", "afterText": " daemon, monitors the status of the local node, and starts and shuts down the worker process of the node when necessary according to Nimbus instructio", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">A daemon that runs on each worker node in a Storm cluster, which monitors the status of the local node and starts or shuts down worker processes based on instructions from Nimbus.</span>}</div>"}, {"index": 12, "class": "CONCEPT", "text": "Micro-batch Stream Processing System", "color": "#D2E3FC", "startPos": 4409, "endPos": 4445, "beforeText": "ode when necessary according to Nimbus instructions.\nThere are two ways of stream computing, Native Stream Processing System represented by storm and ", "extractionText": "Micro-batch Stream Processing System", "afterText": " represented by spark\nMicro-batch processing\u00a0is the practice of collecting data in small groups (\u201cbatches\u201d) for the purposes of taking action on (proc", "attributesHtml": "<div><strong>class:</strong> CONCEPT</div><div><strong>attributes:</strong> {<span class=\"lx-attr-key\">definition</span>: <span class=\"lx-attr-value\">The practice of collecting data in small groups (&#x27;micro-batches&#x27;) for processing. It is considered nearly real-time, not truly real-time, and can save computing costs.</span>}</div>"}];
        let currentIndex = 0;
        let isPlaying = false;
        let animationInterval = null;
        let animationSpeed = 1.0;

        function updateDisplay() {
          const extraction = extractions[currentIndex];
          if (!extraction) return;

          document.getElementById('attributesContainer').innerHTML = extraction.attributesHtml;
          document.getElementById('entityInfo').textContent = (currentIndex + 1) + '/' + extractions.length;
          document.getElementById('posInfo').textContent = '[' + extraction.startPos + '-' + extraction.endPos + ']';
          document.getElementById('progressSlider').value = currentIndex;

          const playBtn = document.querySelector('.lx-control-btn');
          if (playBtn) playBtn.textContent = isPlaying ? '⏸ Pause' : '▶️ Play';

          const prevHighlight = document.querySelector('.lx-text-window .lx-current-highlight');
          if (prevHighlight) prevHighlight.classList.remove('lx-current-highlight');
          const currentSpan = document.querySelector('.lx-text-window span[data-idx="' + currentIndex + '"]');
          if (currentSpan) {
            currentSpan.classList.add('lx-current-highlight');
            currentSpan.scrollIntoView({block: 'center', behavior: 'smooth'});
          }
        }

        function nextExtraction() {
          currentIndex = (currentIndex + 1) % extractions.length;
          updateDisplay();
        }

        function prevExtraction() {
          currentIndex = (currentIndex - 1 + extractions.length) % extractions.length;
          updateDisplay();
        }

        function jumpToExtraction(index) {
          currentIndex = parseInt(index);
          updateDisplay();
        }

        function playPause() {
          if (isPlaying) {
            clearInterval(animationInterval);
            isPlaying = false;
          } else {
            animationInterval = setInterval(nextExtraction, animationSpeed * 1000);
            isPlaying = true;
          }
          updateDisplay();
        }

        window.playPause = playPause;
        window.nextExtraction = nextExtraction;
        window.prevExtraction = prevExtraction;
        window.jumpToExtraction = jumpToExtraction;

        updateDisplay();
      })();
    </script>